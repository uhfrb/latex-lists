\ProvidesPackage{lists}

% BEGIN DEBUGGING MACROS - MAKE INTO A SEPERATE FILE MAYBE EVENTUALLY
\RequirePackage{trace}                       % For debugging only

\newif\ifdebug
\debugtrue
\def\dblog#1{\ifdebug\wlog{[DEBUG]: #1}\fi}  % For debugging only
% END DEBUGGING MACROS   - MAKE INTO A SEPERATE FILE MAYBE EVENTUALLY

\newcommand*\ifcounter[1]{%       Taken unaltered from https://tex.stackexchange.com/questions/155776/check-if-counter-exists
  \ifcsname c@#1\endcsname%       Necessary to allow redefining a list with a name already given
    \expandafter\@firstoftwo
  \else
    \expandafter\@secondoftwo
  \fi
}


\def\emptystring{}
\def\csvsep{,}

\edef\emptylist{[]}

\def\lists@head\list@cons#1#2#3{#2}
\def\lists@tail\list@cons#1#2#3{#1}
\def\lists@sep\list@cons#1#2#3{#3}

\def\lists@iterate#1#2{%
  %
  \dblog{----------------- Start of iteration -----------------}%
  %
  \edef\tmp{#1}%
  \dblog{Current list: \tmp}%
  %
  \def\lists@curr@h{\expandafter\lists@head#1}%
  \def\lists@curr@t{\expandafter\lists@tail#1}%
  \dblog{Current tail: \lists@curr@t}%
  \dblog{Current head: \lists@curr@h}%
  %
  #2{\lists@curr@h}%
  \dblog{Current command: \unexpanded{#2{\lists@curr@h}}}%
  %
  \def\tmp{\csname \lists@curr@t\endcsname}%
  \edef\tmpflag{\tmp}%
  \dblog{Flag: \expandafter\noexpand\tmpflag}%
  \dblog{}%
  %
  \ifx\emptylist\tmpflag%
  \else%
    \expandafter\expandafter\expandafter\lists@iterate\tmp#2%
  \fi%
}

\def\lists@foldl#1#2#3{%
  %
  \dblog{----------------- Start of foldl iteration -----------------}%
  %
  \edef\tmp{#1}%
  \dblog{Current list: \tmp}%
  \dblog{Current accumulator: #3}%
  %
  \def\lists@curr@h{\expandafter\lists@head#1}%
  \def\lists@curr@t{\expandafter\lists@tail#1}%
  \dblog{Current tail: \lists@curr@t}%
  \dblog{Current head: \lists@curr@h}%
  %
  \def\tmp{\csname \lists@curr@t\endcsname}%
  \edef\tmpflag{\tmp}%
  \dblog{Flag: \expandafter\noexpand\tmpflag}%
  \dblog{}%
  %
  \ifx\emptylist\tmpflag%
    #3%
  \else%
    \edef\newAcc{#2{\lists@curr@h}{#3}}%
    \expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter%
    \lists@foldl\expandafter\tmp\expandafter#2\expandafter\newAcc%
  \fi%
}

\def\lists@map#1#2{%
  %
  \dblog{--------------- Start of map iteration ---------------}%
  \dblog{Current list: #1}
  %
  \def\lists@curr@h{\expandafter\lists@head#1}%
  \edef\lists@curr@t{\expandafter\lists@tail#1}%
  \edef\lists@curr@s{\expandafter\lists@sep#1}%
  %
  \dblog{Pattern matching successful}%
  \edef\tmpflag{\csname\lists@curr@t\endcsname}%
  %
  \ifx\emptylist\tmpflag%
  \else%
    \edef\tmpItem{#2{\lists@curr@h}}%
    \dblog{Old item: \lists@curr@h}%
    \dblog{New item: \tmpItem}%
    \dblog{Tail: \lists@curr@t}%
    %                                               
    \expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter%               Theoretically, the more elegant solution described in https://tex.stackexchange.com/questions/104506/expanding-arguments-before-macro-call
    \def\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter%           might also work, but I have not been able to solve my issues through it.
    #1\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter%
    {\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter%
    \list@cons\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter%
    {\expandafter\expandafter\expandafter\lists@curr@t\expandafter\expandafter\expandafter}%
    \expandafter\expandafter\expandafter{\expandafter\tmpItem\expandafter}%
    \expandafter{\lists@curr@s}}%   
    %
    \expandafter\def\expandafter\tmp\expandafter{\csname\lists@curr@t\endcsname}%
    \dblog{Redefinition successful, value now \expandafter\noexpand#1}%
    \expandafter\lists@map\tmp#2%
    \dblog{Recursion successful, value now #1}%
  \fi%
}

\def\iterate#1#2{%
  \dblog{=================== Begin iterate ====================}%
  \edef\tempA{list@#1@cons@item\arabic{list@#1@count}}
  \def\tempB{\csname \tempA\endcsname}%
  \expandafter\expandafter\expandafter\lists@iterate\tempB#2%
}

\def\map#1#2{%
  \dblog{===================== Begin map ======================}%
  \edef\tempA{list@#1@cons@item\arabic{list@#1@count}}
  \def\tempB{\csname \tempA\endcsname}%
  \expandafter\expandafter\expandafter\lists@map\tempB#2%
}

\def\foldl#1#2#3{
  \dblog{==================== Begin foldl =====================}%
  \edef\tempA{list@#1@cons@item\arabic{list@#1@count}}
  \def\tempB{\csname \tempA\endcsname}%
  \expandafter\expandafter\expandafter\lists@foldl\tempB#2#3%
}

\newcommand{\declarelist}[2]
{
    \expandafter\edef\csname list@#1@cons@item0\endcsname{\emptylist}
    \expandafter\edef\csname list@#1@sep\endcsname{#2}
    \ifcounter{list@#1@count}{\setcounter{list@#1@count}{0}}{\newcounter{list@#1@count}}
} 

\def\list@cons#1#2#3{%
  (#2#3\csname #1\endcsname)%
}

\def\getsep#1{\csname list@#1@sep\endcsname}

\def\unused#1#2{% REMOVE EVENTUALLY PROBABLY
  \ifx\emptylist#1%
    \expandafter\def\csname list@#1\endcsname{\emptystring}%
    \expandafter\def\csname list@#1@csv\endcsname{\emptystring}%
  \fi%
  \edef\temp{\csname list@#1\endcsname}%
  \ifx\emptystring\temp%
    \expandafter\edef\csname list@#1\endcsname{#2}%
  \else%
    \expandafter\edef\csname list@#1\endcsname{%
      \temp\csname list@#1@sep\endcsname#2}%
  \fi%
  %
  \edef\temp{\csname list@#1@csv\endcsname}%
  \ifx\emptystring\temp%
    \expandafter\edef\csname list@#1@csv\endcsname{#2}%
  \else%
    \expandafter\edef\csname list@#1@csv\endcsname{%
      \temp\csvsep#2}%
  \fi%
}

\newcommand{\declarecsvlist}[1]{\declarelist{#1}{, }}

\def\lists@concat@curr{\emptystring}

\def\lists@concat#1#2{%
  \edef\temp{#1}%
  \ifx\emptystring\temp%
    \edef\lists@concat@curr{#2}%
  \else%
    \edef\lists@concat@curr{%
      \temp#2\lists@concat@curr}%
  \fi%
}%

\newcommand{\getlist}[1]{\foldl{#1}{\lists@concat}{\emptystring}}

% Appends a new item to the list specified by #1
\def\appendtolist#1#2{%
  \dblog{================ Begin append ===============}%
  %
  \edef\tempA{list@#1@cons@item\arabic{list@#1@count}}%
  \dblog{Appending #2 to #1 -> \tempA \space CONS #2}
  %
  \stepcounter{list@#1@count}%
  \edef\tempB{list@#1@cons@item\arabic{list@#1@count}}%
  %
  \expandafter\expandafter\expandafter%                                         This is disgusting. Unfortunately, I have no idea
  \def\expandafter%                                                             how to get TeX to expand the macros I want expanded
  \csname\expandafter\tempB\expandafter%                                        with fewer calls to \expandafter.
  %                                                                             For future reference: These are \tempA and \csname respectively.
  \endcsname\expandafter{\expandafter%                                                  
  \list@cons\expandafter{\tempA}{#2}{\getsep{#1}}}%
  %
  \dblog{}%
}

\newcommand{\doforall}[2]
{
  \iterate{#1}{#2}
  \PackageWarning{lists}{\noexpand\doforall is deprecated, use \noexpand\iterate instead.}
}

\newcommand{\IfElseEmpty}[3]
{
  \ifnum\value{list@#1@count} = 0%
    #2
  \else%
    #3
  \fi%
}

\newcommand{\IfEmpty}[2]{\IfElseEmpty{#1}{#2}{}}

\newcommand{\IfNotEmpty}[2]{\IfElseEmpty{#1}{}{#2}}

\newcommand{\getcount}[1]{\value{list@#1@count}}